# 목차
1. [약수의 합](#📌_약수의_합)
2. [리스트 요소 삭제하기](#📌_리스트_요소_삭제하기)
3. [최대공약수, 최소공배수 구하기](#📌_최대공약수_최소공배수_구하기)


# 📌 약수의 합
- 약수를 구할때 -> n+1 까지 전부 연산해줄 필요가 없다
```
약수를 계산하는 방법을 떠올려보면 1, 2, 3 하고 이와 곱해져서 나오는 값들을 알아서 채워넣는 식으로 구했다..
그래서 절반정도까지만 하고 나면 그 이후는 할 필요가 없다!!! 단.. 자기 자신은 해야함..
```
- 💡 해결
```python
def solution(n):
  return num + [i for i in range(1, n//2 +1) if n%i == 0]
```

# 📌 리스트 요소 삭제하기

- 리스트 요소를 삭제하는 방법은 2가지가 있다.

### 💡 방법 1 : `del` 함수 이용하기
```python 
>>> a = [4, 7, 8]
>>> del a[1] # index 입력 / slicing도 가능
>>> print(a)
[4, 8]
```

### 💡 방법2 : `remove`함수 이용하기
- 인덱스를 이용하는 것이 아니라, 해당 요소를 이용한다

```python 
>>> a = [4, 7, 8]
>>> a.remove(4) # 요소를 직접입력
>>> print(a)
[7, 8] 
```

# 📌 최대공약수 최소공배수 구하기

## 최대공약수

### 💡 방법1 : 2부터 min(a,b) 까지 나눠서 구하는 방법

```python
gcd_ =  0

for i in range(2, min(a, b)):
  if a%i == 0 and b%i == 0:
    gcd_ = i
```


### 💡 방법2 : 유클리드 호제법을 이용하는 방법

```
⏰ 시간복잡도
- $O(N)$ 으로 구할 수 있다
```

방법론
- gcd(a, b) == gcd(b, a%b) 
  - a%b = r 
  - gcd(b, r) , b%r = r'
  - gcd(r', r) 을 반복
  - r == 0 이 되게 하는 값이 최대 공약수

```python
# 유클리드 호제법 (1) : 재귀함수 이용하기
  ## 단, a >= b
def gcd(a, b):
  if b == 0:
    return a
  else:
    return gcd(b, a%b)
```


```python 
# 유클리드 호제법 (2) : 재귀 없이 하기

while b != 0 :
  a, b = b, a%b

print(a)
```

## 최소공배수
- 두 수의 공통된 배수 중에서 가장 작은 배수
- lcm = gcd * (a/gcd) * (b/gcd)

# 📌 `int` 로 진법 바꾸기
```
int('숫자의 문자열', 문자열의 진법) = 10진법
```
